<?php

class Singleton {
    
    /**
     * Use constants for immutable types instead of variables
     * Use descriptive names
     */
    const STRING_A     = 'A';
    const STRING_A_LONG = 'stringA';
    const STRING_B_LONG = 'stringB';
    const STRING_NON_A = '^A';
    const STRING_NON_B = '^B';
    const STRING_NON_C = '^C';
    const STRING_ABC   = 'ABC';
    const INT_A = 1;
    const INT_B = 2;
    
    /**
     * Describe method properties
     * Prefix private/protected methods/properties with underscore (_)
     * 
     * @var Singleton
     */
    private static $instance;

    /**
     * Use PHPDoc style comments
     * 
     * Restricts the instantiation of this class
     */
    private function __construct() {}

    /**
     * Prevents this class from being cloned
     */
    private function __clone() {}

    /**
     * Checks if there's an instance of the class.
     * If not, it will create a new instance of itself
     */
    public static function getInstance(): self {
        if (!isset(self::$instance)) {
            self::$instance = new self;
        }

        return self::$instance;
    }

    /**
     * Display user name
     * 
     * Spacing/alignment matter
     */
    function userEcho($name) {
        // No need for this
        # $singleton = Singleton::getInstance();
        
        // Don't change method arguments
        # $name = $_POST['userName'];
        
        // Don't introduce new strings
        # if ($singleton->validateName($name)) {
        #     echo "The value of 'name' is '{$name}'";
        # } else {
        #     echo "Please type only letters.";
        # }
        
        // Validate type and length
        if (!is_string($name) || !strlen($name)) {
            throw new Exception('Name is not a valid string');
        }

        // Clean-up (prevent XSS)
        $name = filter_var($name, FILTER_SANITIZE_STRING);
        
        // Clean-up
        echo "The value of 'name' is '{$name}'";
    }

    /**
     * Query by user name
     */
    function userQuery($name) {
        // This method is not static, so it already has access to $this
        # $singleton = Singleton::getInstance();
        
        // Don't change method names, don't assume input origin
        # $name = $_POST['userName'];

        // Don't output new strings
        # if ($singleton->validateName($name)) {
        #    echo "The name '{$name}' was found on the database";
        # } else {
        #    echo "Invalid name";
        # }
        
        // Use built-in functions for SQL escaping
        mysql_query(
            sprintf(
                "SELECT * FROM `test` WHERE `name` = '%s' LIMIT 1",
                // For certain encodings this is not effective
                // Always use 'utf8'
                mysql_real_escape_string($name)
            ),
        );
    }

    /**
     * Output the contents of a file
     */
    function userFile($path) {
        // Don't change metod argument names
        // Don't read file in memory - this might lead to OOM issues
        # $readfile = file_get_contents($file);
        // Why assume we should remove tags?
        # $sanitizedFile = filter_var($readfile, FILTER_SANITIZE_STRING);

        // User paths are relative to this root
        $root = '/real/path/to/files';

        // The main point is to never allow users to perform directory traversal
        // Special characters like "." and ".." and direct root access should be forbidden
        if (!is_string($path) || !strlen($path)) {
            throw new Exception('No file path provided');
        }

        // Validate relative path, file name and extension
        if (!preg_match('%^(?:allowed_path_a|allowed_path_b)\/\w+\.(?:ext|png|jpe?g)$%i', $path)) {
            throw new Exception('Invalid file path');
        }

        // File not found; also check that the path points to a file, not a directory
        if (!is_file("$root/$path")) {
            throw new Exception('File not found');
        }

        readfile("$root/$path");
    }

    /**
     * Nested conditions
     */
    function nestedConditions() {
        // A long string of short-if statements is less readable than the nested ifs
        do {
            if (!$conditionA) {
                echo self::STRING_NON_A;
                break;
            }

            if (!$conditionB) {
                echo self::STRING_NON_B;
                break;
            }

            if (!$conditionC) {
                echo self::STRING_NON_C;
                break;
            }

            echo self::STRING_ABC;
        } while(false);
    }

    /**
     * Return statements
     *
     * @return boolean
     */
    function returnStatements($boolean) {
        // Don't alter the function behavior
        if ($conditionA) {
            echo self::STRING_A;
        }

        // Implicit boolean conversion
        return !!$conditionA;
    }

    /**
     * Null coalescing
     */
    function nullCoalescing() {
        return $_GET['name'] ?? $_POST['name'] ?? 'nobody';
    }

    /**
     * Method chaining
     * 
     * @return $this
     */
    function methodChained() {
        return $this;
    }

    /**
     * Immutables are hard to find
     */
    function checkValue($value) {
        $result = null;
        
        // We should't use constants (strings, ints) locally
        // Store them as class constants instead
        switch ($value) {
            case self::STRING_A_LONG:
                $result = INT_A;
                break;
                
            case self::STRING_B_LONG:
                $result = INT_B;
                break;
        }
        
        return $result;
    }

    /**
     * Check a string is a 24 hour time
     * 
     * @return boolean
     */
    function regexTest($time24Hour) {
        // Don't output new strings
        // No need to sanitize further, a regex will do
        // [0-9] is equivalent to \d
        // 0 left padding - so [01]\d instad of [01]?\d (02:00 instead of 2:00)
        // DRY - don't repeat yourself, the 00-59 minute/second block can appear once or twice
        // Don't use capturing blocks if you don't need them - (?:) instead of ()
        // preg_match returns 0,1 or false; expected return value is boolean
        return !!preg_match('#^(?:[01]\d|2[0-3])(?:\:[0-5]\d){1,2}$#', $time24Hour);
    }
}

/**
 * SoC - Separation of Concerns
 *  A PHP file should either work as a silent library or a template file, not both
 *  Template files should not output text when accessed directly
 */
